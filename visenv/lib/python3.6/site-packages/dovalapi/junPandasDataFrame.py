import numpy as np
import pandas
import re

from .junUtils import to_np_numeric


class PandasDataFrame(object):
    """
    The base DataFrame object which interfaces with pandas DataFrames. This
    class can be used as super class when the sub class supplies a pandas
    dataframe and needs interfacing methods for it which do not come with the
    regular pandas DataFrame.
    """

    def __init__(self, dataframe, label_set=None, label_name=None):
        self.df = dataframe
        self.label_name = label_name
        self.label_set = label_set or list()
        self._real_label_values = label_set or list()
        self._checked_columns = set()

    def infer_types(self, features=None):
        if features is None:
            features = self.get_features()
        else:
            features = set(self.get_features()).intersection(set(features))
        for column in features:
            if column in self._checked_columns:
                continue
            self._checked_columns.add(column)
            current_type = str(self.df[column].dtype)
            if 'int' in current_type or 'float' in current_type:
                continue
            cleaned_values = list(map(
                lambda value: str(value).strip().replace(',', ''),
                self.df[column].values))

            skip_column = False
            for cleaned_value in cleaned_values:
                if not re.match('^\-?\d+(\.\d+)?$', cleaned_value):
                    skip_column = True
                    break

            if not skip_column:
                self.df[column] = to_np_numeric(np.array(cleaned_values))

    def remove_sample_identifiers(self):
        """
        Removes the row names from the internal data frame
        """
        self.df.index = pandas.RangeIndex(len(self.df.index))

    def set_sample_identifiers(self, feature):
        """
        Sets a feature as sample identifiers, setting the row names on the
        internal dataframe.

        :param feature: The feature name which represents the samples
        :type feature: str
        """
        if feature not in self.get_features():
            raise ValueError('Feature ' + feature + ' not available')
        self.df.set_index(feature, inplace=True)

    def get_dataframe(self, *features):
        """
        Returns the data, optionally filtered by the selected features.

        :param features: A feature to include
        :type features: str

        :return: A pandas DataFrame containing the data, optionally filtered \
            by the selected features.
        :rtype: pandas.DataFrame
        """
        if features:
            return self.df.loc[:, features]
        return self.df[:]

    def _collect_data(self, evaluator):
        """
        Collects data based on an evaluator. This evaluator gets called with a
        feature string and can either return True or False, which respectively
        mean that the feature should be included or excluded.

        :param evaluator: The evaluator which determines whether to include or\
            exclude a feature
        :type evaluator: callable

        :return: A PandasDataFrame containing the data of the selected features
        :rtype: PandasDataFrame
        """
        features = []
        for feature in self.get_features():
            if evaluator(feature):
                features.append(feature)
        return PandasDataFrame.create_new(self, self.df[features])

    def filter_rows(self, evaluator):
        """
        Filters the row based on the evaluator. The evaluator takes two
        parameters:
        1. values: A numpy array of all the values
        2. features: A numpy array of all features

        :param evaluator: The evaluator which decides whether to keep the row \
            or not (respectively returns True or False)
        :type evaluator: callable

        :return: The filtered PandasDataFrame
        :rtype: PandasDataFrame
        """
        do_filter = []
        for _, row in self.df.iterrows():
            features = row.axes[0].values
            do_filter.append(bool(evaluator(row.values, features)))
        kwargs = dict(label_set=self.label_set, label_name=self.label_name)
        if self.label_set:
            kwargs['label_set'] = list(
                filter(lambda idx, item: do_filter[idx],
                       range(len(self.label_set))))
        return PandasDataFrame(self.df.loc[do_filter], **kwargs)

    def get_features(self):
        """
        Retrieves all the features of the dataset, excluding the selected
        labels.

        :return: An array containing all feature names
        :rtype: list
        """
        return list(self.df.columns.get_values())

    def set_features(self, features):
        """
        Set the feature names

        :param features: A list of new feature names
        :type features: list
        """
        delta = len(features) - self.df.shape[1]
        if delta != 0:
            err = 'Got too {} features: got {}, need {}'.format(
                'much' if delta > 1 else 'few',
                len(features), self.df.shape[1])
            raise ValueError(err)
        self.df.columns = pandas.Series(features)

    def remove_feature(self, feature):
        """
        Remove the feature from the dataset

        :param feature: The feature name
        :type feature: str

        :return: The PandasDataFrame with the dropped feature
        :rtype: PandasDataFrame
        """
        if feature not in self.get_features():
            raise ValueError('Feature {} does not exist!'.format(feature))
        return PandasDataFrame.create_new(
            self, self.df.drop([feature], axis=1))

    def remove_features(self, *features):
        """
        Remove multiple features from this dataset

        :param features: The features to remove
        :type features: str

        :return: The PandasDataFrame with the dropped features
        :rtype: PandasDataFrame
        """
        available_features = self.get_features()
        features_are_available = list(
            map(lambda f: f in available_features, features))
        if not all(features_are_available):
            unavailable_features = pandas.Series(self.df.columns).loc[
                features_are_available]
            raise ValueError('The features {} don\'t exist!'.format(
                ', '.join(unavailable_features.get_values())))
        return PandasDataFrame.create_new(self, self.df.drop(features, axis=1))

    def add_feature(self, feature, data):
        """
        Adds a feature to the dataset

        :param feature: The name of the feature
        :type feature: str

        :param data: Data which can be converted to a numpy array (list, array\
            itself)
        :type data: list

        :raise ValueError: When the feature already exists
        :raise ValueError: When the data contains too few or much rows
        """
        if feature in self.get_features():
            raise ValueError('Feature ' + feature + ' already exists!')
        if len(data) != self.get_row_amount():
            raise ValueError(('Incorrect amount of rows, expected {} rows ' +
                              'but got {}')
                             .format(self.get_row_amount(), len(data)))
        self.df.loc[:, feature] = pandas.Series(
            data=np.array(data), index=self.df.index)
        self.infer_types()

    def add_features(self, features, data):
        """
        Adds multiple features to the dataset.

        :param features: A list of strings representing the feature names
        :type features: list

        :param data: Data with the same amount sub lists/arrays to represent\
            all features
        :type data: list

        :raise ValueError: When too few or much sublists are available \
        :py:meth:`juniper.dataset.PandasDataFrame.add_feature`
        """
        if len(features) != len(data):
            raise ValueError('Received {} features but {} datasets')
        for i in range(len(features)):
            self.add_feature(features[i], data[i])

    def is_numeric(self, feature):
        """
        Checks whether the feature is numeric or not

        :param feature: The name of the feature
        :type feature: str

        :return: A boolean indicating whether the feature is numeric or not ( \
            respectively True or False)
        :rtype: bool
        """
        if feature not in self.get_features():
            raise ValueError('Feature {} does not exist!'.format(feature))
        type_ = str(self.df[feature].dtype)
        return 'int' in type_ or 'float' in type_

    def get_numeric_features(self):
        """
        Retrieves all features which are all numeric

        :return: A list of features which are inferred as numeric
        :rtype: list
        """
        return list(filter(self.is_numeric, self.get_features()))

    def is_all_numeric(self):
        """
        Checks whether all features are numeric or not.

        :return: A boolean indicating whether the dataset is numeric or not ( \
            respectively True or False)
        :rtype: bool
        """
        return len(self.get_features()) == len(self.get_numeric_features())

    def get_numeric_data(self):
        """
        Retrieve the features of the dataset which are numeric

        :return: A pandas DataFrame containing all the features which are \
            numeric
        :rtype: pandas.DataFrame
        """
        features = self.get_numeric_features()
        if features:
            return self.get_dataframe(*features)
        return pandas.DataFrame()

    def is_nominal(self, feature):
        """
        Checks whether the feature is nominal or not

        :param feature: The name of the feature
        :type feature: str

        :return: A boolean indicating whether the feature is nominal or not ( \
            respectively True or False)
        :rtype: bool
        """
        return not self.is_numeric(feature)

    def get_nominal_features(self):
        """
        Retrieves all features which are all nominal

        :return: A list of features which are inferred as nominal
        :rtype: list
        """
        return list(filter(self.is_nominal, self.get_features()))

    def is_all_nominal(self):
        """
        Checks whether all features are nominal or not.

        :return: A boolean indicating whether the dataset is nominal or not ( \
            respectively True or False)
        :rtype: bool
        """
        return len(self.get_features()) == len(self.get_nominal_features())

    def get_nominal_data(self):
        """
        Retrieve the features of the dataset which are nominal

        :return: A pandas DataFrame containing all the features which are \
            nominal
        :rtype: pandas.DataFrame
        """
        features = self.get_nominal_features()
        if features:
            return self.get_dataframe(*features)
        return pandas.DataFrame()

    def get_row_amount(self):
        """
        Get the amount of rows in this dataset

        :return: The amount of rows in this dataset
        :rtype: int
        """
        return self.df.shape[0]

    def convert_nominal_to_numeric(self, feature, known_feature_values=None):
        """
        Factorizes nominal values to numeric values. Similair to
        pandas.factorize, but this preserves the index.

        :param feature: The feature to factorize
        :type feature: str

        :param known_feature_values: A list of feature values which were \
            previously known to convert the nominal feature to numeric \
            consistently with previous calls
        :type known_feature_values: list

        :return: A list of known values ordered in a list
        :rtype: list
        """
        sub_values = list(set(self.df[feature].values))
        sub_values.sort()
        if known_feature_values and known_feature_values != sub_values:
            for known_feature_value in known_feature_values:
                if known_feature_value in sub_values:
                    sub_values.remove(known_feature_value)
            known_feature_values.extend(sub_values)
            sub_values = known_feature_values
        # Do the actual conversion
        self.df.loc[:, [feature]] = np.array(
            [[sub_values.index(v)] for v in self.df[feature].values])
        return sub_values

    def set_label(self, feature):
        """
        Sets the feature as the label for this dataset

        :param feature: The name of the feature to set as label
        :type feature: str

        :return: A boolean indicating whether this was successful
        :rtype: bool
        """
        if self.label_name == feature:
            return True
        if feature not in self.df.columns.values:
            return False
        if self.label_name is not None:
            self.remove_label()
        self.label_name = feature
        self.label_set = list(map(
            lambda item: str(item).lower(),
            self.df.loc[:, feature].values))
        self._real_label_values = list(self.df.loc[:, feature].values)
        del self.df[feature]
        self.infer_types()
        return True

    def evaluate_labels(self, evaluator):
        """
        Create a list of booleans by applying a callable to the corresponding
        label value

        :param evaluator: A callable which takes a label value as parameter\
            and returns True or False
        :type evaluator: callable

        :return: A list of bools
        :rtype: list
        """
        if not self.label_set:
            raise ValueError('Nothing to filter on')
        rows = map(evaluator, self.label_set)
        return list(map(bool, rows))

    def get_label_info(self):
        """
        Returns the label info: a tuple of a list of the values and the
        feature name

        :return: A tuple containg the label set (first index) and label name \
            (second index)
        :rtype: tuple
        """
        return list(self.label_set), self.label_name

    def remove_label(self):
        """
        Removes the label from this dataset and adds the feature again to the
        dataset.
        """
        if self.label_name is None:
            raise ValueError("Label is not set!")
        self.df[self.label_name] = np.array(self._real_label_values)
        self.label_name = None
        self.label_set = list()
        self._real_label_values = list()
        self.infer_types()

    @staticmethod
    def create_new(dataframe, dataset=pandas.DataFrame):
        """
        Creates a new PandasDataFrame by using the older label information and
        a regular pandas DataFrame. Also carries over the sample identifiers
        if available.

        :param dataframe: The PandasDataFrame which supplies the label info
        :type dataframe: PandasDataFrame

        :param dataset: The DataFrame which contains the "new" data
        :type dataset: pandas.DataFrame

        :return: The newly created PandasDataFrame with the old label info \
            and new data.
        :rtype: PandasDataFrame
        """
        label_set, label_name = dataframe.get_label_info()
        dataset.index = dataframe.df.index
        return PandasDataFrame(
            dataset, label_set=label_set, label_name=label_name)
