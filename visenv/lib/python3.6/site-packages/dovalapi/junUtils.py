import json
import re
from collections import OrderedDict

import numpy as np


def to_np_numeric(np_array):
    """
    Makes sure a Numpy array is a numeric one. When for example calculating
    the mean on a Numpy array which has dtype object, the calculation will
    fail.

    :param np_array: The array to make sure of it is numeric
    :type np_array: np.ndarray

    :return: A numeric Numpy array
    :rtype: np.ndarray
    """
    original_dtype = np_array.dtype.name
    if 'int' in original_dtype or 'float' in original_dtype:
        return np_array
    dtype = np.int64
    if any(map(lambda i: '.' in str(i), np_array)):
        dtype = np.float64
    return np_array.astype(dtype)


def float_range(start, stop=None, step=1):
    """
    Can be used like the range function but allows for float values. Please
    refer to the range documentation for information about the arguments
    """
    if stop is None:
        start, stop = 0, start
    if abs(start + step - stop) > abs(start - stop):
        return
    while start < stop:
        yield start
        start += step


def range_with_exclusion(start, stop=None, step=1, exclusion=None):
    """
    Applies a float_range iterator and removes the items in the
    exclusion list. Please also refer to the range documentation
    how to use the first 3 arguments.

    :param exclusion: A list of values which should be excluded
    :type exclusion: list

    :yields: The next index
    """
    if exclusion is None:
        exclusion = list()
    elif not isinstance(exclusion, list):
        exclusion = list(exclusion)
    for i in float_range(start, stop, step):
        if i not in exclusion:
            yield i


class BidirectionalDict(object):
    """
    A dictionary which is bidirectional: returns the key when the value is
    given and returns the value when the key is given. This means that the
    values are also treated as keys: they should be unique.
    """

    def __init__(self):
        self._items = []
        self._len = 0

    def items(self):
        return zip(self.keys(), self.values())

    def keys(self):
        return map(
            lambda idx: self._items[idx],
            filter(lambda idx: idx % 2 == 0, range(len(self._items))))

    def values(self):
        return map(
            lambda idx: self._items[idx],
            filter(lambda idx: idx % 2 == 1, range(len(self._items))))

    def to_dict(self):
        return OrderedDict(self.items())

    def available_pair(self, a, b):
        return (a not in self.keys() and b not in self.keys()
                and a not in self.values() and b not in self.values())

    def __setitem__(self, key, value):
        if not self.available_pair(key, value):
            raise ValueError("Combination already exists: ({}, {})"
                             .format(str(key), str(value)))
        self._items.append(key)
        self._items.append(value)
        self._len += 1

    def _get_idx(self, item):
        idx = self._items.index(item)
        return idx, 1 if idx % 2 == 0 else -1

    def __getitem__(self, item):
        try:
            idx, offset = self._get_idx(item)
        except ValueError:
            raise KeyError(str(item))
        return self._items[idx + offset]

    def __delitem__(self, key):
        try:
            idx, offset = self._get_idx(key)
        except ValueError:
            raise KeyError(str(key))
        if offset > 0:
            del self._items[idx + offset]
            del self._items[idx]
        else:
            del self._items[idx]
            del self._items[idx + offset]

    def __len__(self):
        return self._len

    def __str__(self):
        return str(self.to_dict())
